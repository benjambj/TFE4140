\subsection{Lifetime Expectancy Calculations}
To perform the required lifetime expectancy calculations, some
assumptions about the stochastic behaviour of the microcontrollers are
made. An assumption that was provided by the problem text, was that
the expected lifetime of a single microcontroller was six years. In
addition to this, we assumed that the lifetime of each microcontroller
followed an exponential probability distribution, and that their
individual lifetimes are independent. 

The first assumption is made because the exponential distribution is
simple to use for calculations. Even though it is not suitable for
describing the lifetime of an entire technical device, it is used
extensively in reliability theory\cite{wikipedia}. Thus, it should
providing an estimate of how the system behaves. It was also suggested
by the course staff.

The second assumption is also somewhat optimistic, since the
microcontrollers are exposed to the same environmental hazards at the
same time. For instance, a solar flare will most likely strike all the
microcontrollers simultaneously, and thus microcontroller lifetimes
are likely to have a non-zero covariance. The assumption is still made
to make the calculations easier. If a more accurate model is
desirable, dependence should be taken into account.

With these assumptions, $f(t) = \frac{1}{6}e^{-\frac{1}{6}t}$ is the
probability density function of a failure event for an individual
microcontroller, and $F(t) = 1 - e^{-\frac{1}{6}t}$ is the
corresponding cumulative distribution giving the probability that the
microcontroller has failed within time $t$. Consequently, we can
define $P(t) := 1 - F(t) = e^{-\frac{1}{6}t}$ to be the probability
that the microcontroller has not failed within time $t$. Assuming as
we have that each microcontroller is independent, we can view the
potential of failure within a given time as a Bernoulli trial for each
of the microcontrollers. Consequently, the probability that exactly
$r$ microcontrollers have not failed within time $t$, as a function of
$t$, is given by $Q(r) = \binom{4}{r}P(t)^4(1 - P(t))^{4 - r})$. With
this framework, we can begin answering the questions stated in
\autoref{sec:problem}.

\subsubsection{Calculation of Probability of Error in Maximum One Controller}
\label{sec:errorinmaxone}
The probability that at most one controller has failed is the
probability that either four or three controllers are still
working. Since these two events are independent---there cannot be both
exactly four and exactly three microcontrollers that are still working
at a point in time---the total probability is the sum of the
probability of each event. Hence, the probability of an error in at
most one controller within a given time $t$ is given by

\begin{align*}
    Q(4) + Q(3) &= \binom{4}{4}P(t)^4 + \binom{4}{3}P(t)^3(1 - P(t)) \\
                &= (e^{-\frac{t}{6}})^4  + 4 (e^{-\frac{t}{6}})^3(1 - e^{-\frac{t}{6}}) \\
                &= 
\end{align*}

\subsubsection{Calculation of Probability of Error in Maximum Two Controllers}
\label{sec:errorinmaxtwo}
This probability is the same as the probability that either exactly
four, exactly three or exactly two microcontrollers are still working
by time $t$. By the same logic as given in
\autoref{sec:errorinmaxone}, this is the same as
\begin{align*}
  &Q(4) + Q(3) + Q(2) = \\
  &\binom{4}{4}P(t)^4 + \binom{4}{3}P(t)^3(1 - P(t)) + \binom{4}{2}P(t)^2(1 - P(t))^2 = \\
  &
\end{align*}

This function describes the probability that the system is still alive
within time $t$. For future reference, we shall denote it as $R(t)$.

\subsubsection{Calculation of Probability in At Least Three Controllers}
\label{sec:errorinatleastthree}
At least three controllers being broken within time $t$ is the
complement of the event that at most two controllers have failed
within time $t$. Thus, this probability is simply the negation of the
result derived in \autoref{sec:errorinmaxtwo}, which is
\begin{align*}
  1 - R(t) = 1 - (Q(4) + Q(3) + Q(2)) = 
\end{align*}

\subsubsection{Mean Time to Failure}
The mean time to system failure is the expected value of a stochastic
variable $X$ denoting time until at least three microcontrollers have
failed. Now, $Prob\{X \le t\} = Prob\{\text{System has failed within
  time } t\}$, so the cumulative distribution function of $X$,
$F_X(t)$, is given by the result in
\autoref{sec:errorinatleastthree}. If we denote the probability
density function of $X$ by $f_X(t) = \frac{\partial}{\partial
  t}F_x(t)$, we get that

\begin{align*}
  E[X] &= \int_0^{\infty}tf_X(t)dt = \int_0^{\infty}t\frac{\partial}{\partial t} F_X(t)dt \\
       &= \lim_{b \to \infty}[tF_X(t)]_{0}^b - \int_0^{\infty}F_X(t)dt \\
       &= \lim_{b \to \infty}[tF_X(t)]_0^b - \int_0^{\infty}1 - R(t)dt \\
       &= \lim_{b \to \infty}[tF_X(t)]_0^b - \int_0^\infty1dt + \int_0^{\infty}R(t)dt \\
       &= \lim_{b \to \infty}[tF_X(t)]_0^b - \lim_{b \to \infty}[t]_0^b + \int_0^{\infty}R(t)dt \\
       &= \lim_{b \to \infty}(bF_X(b) - 0F_X(0)) - \lim_{b \to \infty}(b - 0) + \int_0^{\infty}R(t)dt \\
       &= \lim_{b \to \infty}bF_X(b) - \lim_{b \to \infty}b + \int_0^{\infty}R(t)dt \\
       &= \lim_{b \to \infty}b\lim_{b \to \infty}F_X(b) - \lim_{b \to \infty}b + \int_0^{\infty}R(t)dt \\
       &= \lim_{b \to \infty}(b - b) + \int_0^{\infty}R(t)dt \\
       &= \int_0^{\infty}R(t)dt
\end{align*}

\todo[inline]{Discuss the MTTF}

%\begin{align*}
%x = 3
%Q(4) + Q(3) &= P(t)^4 + \binom{4}{3}P(t)^3(1 - P(t)) 
%             &= (e^{\frac{t}{6}})^4  + 4 (e^{\frac{t}{6}})^3(1 - e^{\frac{t}{6}})

%%%%%\end{align*}


\subsection{Alternative Solutions}
One of the major goal on this task was to optimize for area useage. In order to achieve the most
efficient solution regarding LUT useage, we came up with three fundamentally different solutions.
Except for the solution described in \autoref{sec:design}, the two 

- Different voting algorithms. Cleaner/faster? Had a 3-LUT one 50 MHz
faster and 3 LUTs smaller with a bug, but with more tinkering it might
be possible to get this to work. 

- Simultaneous calculation of error tags and voted data (is it on
critical path?) Faster?

- Store data in register and calculate ECC from these instead of on
the fly? Cleaner

- More as described in technote?

\subsection{Possible Simplifications of Current Implementation}

\paragraph{SECDED-bit Simplification} \hfill \\
\todo{Reference previous explanation of SECDED bit}. Instead of
performing this XOR operation with the parity bits themselves, one can
exploit the fact that the parity bits are simply an XOR of data bits
to express the overall parity bit just in terms of data bits. To see
this, let $d(i)$ denote data bit $i$ and $p(j)$ denote parity bit $j$.
Then, by substituting the equation for calculating $p(0)$ into the
equation for $p(4)$, we get
\begin{align*}
  p(4) &= d(0) \otimes d(1) \otimes \ldots \otimes d(10) \otimes p(0) \otimes p(1) \otimes p(2) \otimes p(3) \\
  &= d(0) \otimes d(1) \otimes \ldots \otimes d(10) \otimes \\
  & \qquad (d(0) \otimes d(1) \otimes d(3) \otimes d(4) \otimes d(6)
  \otimes d(8) \otimes d(10)) \otimes p(1) \otimes p(2) \otimes p(3) \\
  &= d(2) \otimes d(5) \otimes d(7) \otimes d(9) \otimes p(1) \otimes p(2) \otimes p(3)
\end{align*}

This substitution and simplification could be done with any desirable
combination of parity bits to shift the work between performing XOR
operations with parity bits during the output stage or calculating
state-enable signals during the data parity count accumulation
stage. By experimenting with different combinations, it might be
possible to find a configuration which yields a better
result than the current solution with no simplification does. 

\paragraph{Weaker Assumptions of Microcontroller Data Lines Validity} \hfill \\
In our design, we made the assumption that we should not use the input
data from the microcontrollers to update the error tags outside of
periods in which they were actually sending a word to the Liaison. If
this restriction was relaxed, we would be able to remove a few
registers. The register containing the enable signal, for instance,
would be of no use. It would also be able to shift the responsibility
of making the circuit sequential from the input stage to the output
stage --- instead of using flip-flops for storing the input data from
the microcontrollers, we could use a flip-flop for maintaining the
value of the output signals. Since there would no longer be a need to
avoid updating error tags during a clock period, the prohibiting issue
of enabling the voter for the first data bit would no longer be
present.

\todo[inline]{Is this correct? Could we not have flip flops on output now as well? We would just have to update the enable register in a different way.. but wait, it would have to be set when di\_ready is high!}

