\documentclass[11pt]{article}

\usepackage{graphicx,amsmath,amssymb,url,xspace}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks=true]{hyperref}
\usepackage{parskip}
\newcommand{\eg}{e.g.,\xspace}
\newcommand{\bigeg}{E.g.,\xspace}
\newcommand{\etal}{\textit{et~al.\xspace}}
\newcommand{\etc}{etc.\@\xspace}
\newcommand{\ie}{i.e.,\xspace}
\newcommand{\bigie}{I.e.,\xspace}

\title{Technical Note}
\author{Stian Hvatum and Benjamin BjÃ¸rnseth}

\begin{document}
\maketitle

\section{Task 1}
\label{sec:task1}
We need 12 states to implement the error tagging, since any
combination of the microcontrollers can fail. Since three or more
failures indicate a broken system, we can merge the states
corresponding to these scenarios into one ``System broken'' state,
which means that we do not need the full 16 states. However, since 3
bits are not enough to represent 12 states, we need 4 bits anyways.

From the initial state, you can move to the states a, b, c, d and
System broken, if either microcontroller a, b, c, d fail or two
microcontrollers fail simultaneously (in which case you do not know
which result to trust, and the system has to be considered
broken). From the states a, b, c and d, you can move to states
representing two microcontrollers having failed. For instance, from
state a you can move to state ab, ac or ad if b, c or d fails,
respectively. From any state you can move back to the Initial state if
the reset signal state is set.

\section{Task 2}
\label{sec:task2}

In the following evaluation of our solutions, we will consider the
following critera:
\begin{itemize}

%Evaluation criteria
\item Area
\item Speed
\item Genericalness
\item Readability

\end{itemize}

In our group, we considered four different implementations. 

The first implementation represented the states discussed in
\autoref{sec:task1} explicitly with a custom VHDL state type, and had
a case statement over a state variable which implemented the logic of
each case. This resulted in approximately 300 lines of VHDL code, and
synthesised into 98 LUTs with a maximum clock frequency of 291.3
MHz. It was, as such, hard to read, gigantic, and overall a horrendous
design. Nevertheless, we were taught a bit about how NOT to write VHDL
programs.

The second implementation tried to alleviate this by writing the logic
outside of the sequential process with select statements for
determining the voted output, the status and the next internal
state. In this implementation (as well as the next two), the state was
encoded with a four-bit vector instead of using a state type. This
implementation was significantly shorter, and quite simple to read. It
yielded 19 LUTs, and a clock speed of 280 MHz. It was, however, not
generic in the sense that adding a fifth microcontroller would require
doubling the cases of the different select statements. 

The third implementation used a clever algorithm for performing the
voting, based on summing the number of valid signals with each value
and checking which value was highest, (\ie sum(validOnes) >
sum(validZeroes)). It also used summations over the number of working
signals (\ie our state) to calculate the status output signal. This
design gave us 19 LUTs and a clock frequency of 300 MHz, and was as
such similar to the previous solution. The previous solution computed
the status output signals by using three LUTs, converting the four-bit
state signal into each bit of the status. This solution used more due
to the addition circuitry being more complex as well as also requiring
three LUTs for converting the sum into each of the status bits. When
we combined these two designs (\ie using the sum algorithm for voting
and the plain LUT approach for calculating the status and new internal
state), we ended up with 14 LUTs and a clock frequency of 320 MHz. 

The final implementation took the approach of coding the desired LUTs
of the voter explicitly, taking advantage of structures intrinsic to
the problem. By hand-coding this, we were able to get the voting logic
down to using only 3 LUTs, which resulted in a total circuit size of
10 LUTs. The speed of the circuit was 360 MHz, so this design is
superior in these aspects. It is, however, somewhat harder to read, as
the correct functioning of the expressions in the voting logic is not
necessarily obvious. In the previous solution, it was a lot easier to
convince oneself of correctness. This final solution was also a lot
less generic than the one using addition; in that solution, adding
another input would not change the algorithm, while this solution used
an algorithm specific to four input bits. 

In addition to the techniques used in these solutions, there are other
variants which could be considered. For instance, instead of
calculating the error tags for the different microcontrollers by
looking at whether or not they differ from the voted output, one could
calculate this directly from the input and current failure state. This
should lead to a faster circuit as you do not need to wait for the
voting computation to perform the next-state computation, but we
expect the resulting circuit to be significantly bigger as we believe
the logic for calculating each error tag in this way would be larger
than the 1 LUT required for our current solution.

\section{Task 3}
\label{sec:task3}

We have decided to solve this by performing the voting on the fly. We
use an integer state variable to keep track of which bit emission
stage we are in, where the value 0 represents ``not sending data'' and
a value i > 0 represents ``sending data bit i''. The input signals
from the microcontrollers are propagated into our one bit voter
implementation, which yields a status and vote result output. While in
state 0, we do not set do\_ready, and just emits whatever is
calculated from the voter. When in this stage we cannot assume that
the data from the microcontrollers should be consistent, so the input
to the voter is set to 0 when we are not getting data from the
microcontroller so that no discrepancies are recorded
unnecessarily. When we observe that di\_ready goes high, we set
do\_ready the same cycle and increment the sending state to 1. When
di\_ready goes high, the input to the voter is set to be the
microcontroller signals. Thus, the desired output bit is ready when
the clock transition occurs, so the output of the voter can just be
propagated through as the output of the liaison. When we reach bit
send stage 8, we set the inputs to the voting unit to 0 as the input
from the microcontrollers must be disregarded half a cycle later. When
we reach bit stage 9, we start sending the three status bits one cycle
at a time. When we are about to reach bit stage 12, we have sent all
of data, and if there is no new data from the microcontrollers (as
indicated by di\_ready) we return to the initial bit sending
state. The error tags are maintained, however, as these are separate
memory elements.

An alternative might be to store the calculated data in a register, to
be sent later. This might yield more relaxed timing constraints, which
in turn should give a circuit able to operate at higher clock
frequencies. In turn, it is likely to be a bit bigger, as the register
write-enable logic has to be written in addition to the
output-selection logic.

\end{document}
