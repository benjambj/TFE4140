\documentclass[11pt]{article}

\usepackage{graphicx,amsmath,amssymb,url,xspace}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks=true]{hyperref}
\usepackage{parskip}
\newcommand{\eg}{e.g.,\xspace}
\newcommand{\bigeg}{E.g.,\xspace}
\newcommand{\etal}{\textit{et~al.\xspace}}
\newcommand{\etc}{etc.\@\xspace}
\newcommand{\ie}{i.e.,\xspace}
\newcommand{\bigie}{I.e.,\xspace}

\title{Technical Note}
\author{Stian Hvatum and Benjamin BjÃ¸rnseth}

\begin{document}
\maketitle

\section{Task 1}
\label{sec:task1}
We need 12 states to implement the error tagging, since any
combination of the microcontrollers can fail. Since three or more
failures indicate a broken system, we can merge the states
corresponding to these scenarios into one ``System broken'' state,
which means that we do not need the full 16 states. However, since 3
bits are not enough to represent 12 states, we need 4 bits anyways.

From the initial state, you can move to the states a, b, c, d and
System broken, if either microcontroller a, b, c, d fail or two
microcontrollers fail simultaneously (in which case you do not know
which result to trust, and the system has to be considered
broken). From the states a, b, c and d, you can move to states
representing two microcontrollers having failed. For instance, from
state a you can move to state ab, ac or ad if b, c or d fails,
respectively. From any state you can move back to the Initial state if
the reset signal state is set.

\section{Task 2}
\label{sec:task2}

In the following evaluation of our solutions, we will consider the
following critera:
\begin{itemize}

%Evaluation criteria
\item Area
\item Speed
\item Genericalness
\item Readability

\end{itemize}

In our group, we considered four different implementations. 

The first implementation represented the states discussed in
\autoref{sec:task1} explicitly with a custom VHDL state type, and had
a case statement over a state variable which implemented the logic of
each case. This resulted in approximately 300 lines of VHDL code, and
synthesised into 98 LUTs with a maximum clock frequency of 291.3
MHz. It was, as such, hard to read, gigantic, and overall a horrendous
design. Nevertheless, we were taught a bit about how NOT to write VHDL
programs.

The second implementation tried to alleviate this by writing the logic
outside of the sequential process with select statements for
determining the voted output, the status and the next internal
state. In this implementation (as well as the next two), the state was
encoded with a four-bit vector instead of using a state type. This
implementation was significantly shorter, and quite simple to read. It
yielded 19 LUTs, and a clock speed of 280 MHz. It was, however, not
generic in the sense that adding a fifth microcontroller would require
doubling the cases of the different select statements. 

The third implementation used a clever algorithm for performing the
voting, based on summing the number of valid signals with each value
and checking which value was highest, (\ie sum(validOnes) >
sum(validZeroes)). It also used summations over the number of working
signals (\ie our state) to calculate the status output signal. This
design gave us 19 LUTs and a clock frequency of 300 MHz, and was as
such similar to the previous solution. The previous solution computed
the status output signals by using three LUTs, converting the four-bit
state signal into each bit of the status. This solution used more due
to the addition circuitry being more complex as well as also requiring
three LUTs for converting the sum into each of the status bits. When
we combined these two designs (\ie using the sum algorithm for voting
and the plain LUT approach for calculating the status and new internal
state), we ended up with 14 LUTs and a clock frequency of 320 MHz. 

The final implementation took the approach of coding the desired LUTs
of the voter explicitly, taking advantage of structures intrinsic to
the problem. By hand-coding this, we were able to get the voting logic
down to using only 3 LUTs, which resulted in a total circuit size of
10 LUTs. The speed of the circuit was 360 MHz, so this design is
superior in these aspects. It is, however, somewhat harder to read, as
the correct functioning of the expressions in the voting logic is not
necessarily obvious. In the previous solution, it was a lot easier to
convince oneself of correctness. This final solution was also a lot
less generic than the one using addition; in that solution, adding
another input would not change the algorithm, while this solution used
an algorithm specific to four input bits. 

In addition to the techniques used in these solutions, there are other
variants which could be considered. For instance, instead of
calculating the error tags for the different microcontrollers by
looking at whether or not they differ from the voted output, one could
calculate this directly from the input and current failure state. This
should lead to a faster circuit as you do not need to wait for the
voting computation to perform the next-state computation, but we
expect the resulting circuit to be significantly bigger as we believe
the logic for calculating each error tag in this way would be larger
than the 1 LUT required for our current solution.

\section{Task 3}
\label{sec:task3}

When solving the extended task of voting 8-bit words from the
microprocessors, it is natural to use the one bit voter from task 2 as
a component. It is paramount, however, that the voter is enabled while
the microprocessors are not sending valid data (as indicated by the
di\_ready signal), as this would potentially cause the one bit voter
to enter the broken state even though it has not been receiving valid
input. To remedy this without changing the component, one could make
sure that the input to the one bit voter was equal when valid data was
not received. This would, however, require four LUTs, one for each
input bit. By instead passing a data enabled signal into the one bit
voter, one can alter the one bit voter to better utilise internal
elements, and by doing this we were able to perform the enabilng of
the one bit voter without using any more LUTs than before. A
disadvantage of this method is that the one bit voter no longer would
be as general purpose, and require a redundant extra line constantly
set to 1 to use it as stand alone a one bit voter.

Another crossroad of implementation is how one represents the voting
stage, i.e. how the eight bit voter remembers which bit it is to send
on the output. One way to represent this state is by using a VHDL
integer, which counts the bit number you are currently sending. This
is a solution which is easy to understand, since numbering the bits to
send is natural when sending several bits sequentially. However, the
approach requires LUTs for decoding the binary number, as there is no
direct mapping between a single bit of the state (which would be a
four bit number when sending eleven bits) and which bit you are going
to send. A different way to represent the state would be with one
register for each bit to send, saying whether you are sending this bit
or not. The logic for selecting the output value is reduced, since the
calculations are a lot simpler. The number of registers required is
increased, however, since $n$ bits of output requires $n$ registers
instead of $\lceil log_2(n) \rceil$ registers.

In our solution, we have decided both to alter the one bit voter and
represent the bit send stage with one register per bit to send. This
is done in order to minimize the number of LUTs used in our design. 

We have also decided to solve this by performing the voting on the
fly. The input signals from the microcontrollers are propagated into
our one bit voter implementation, which yields a status and vote
result output. While in state 0, we do not set do\_ready, and just
emits whatever is calculated from the voter. When in this stage we
cannot assume that the data from the microcontrollers should be
consistent, so we set the enable signal of the voter to 0. When we
observe that di\_ready goes high, we set do\_ready the same cycle and
enable the first sending state bit. When di\_ready goes high, the
input to the voter is set to be the microcontroller signals. Thus, the
desired output bit is ready when the clock transition occurs, so the
output of the voter can just be propagated through as the output of
the liaison. When we reach bit send stage 8, we set the inputs to the
voting unit to 0 as the input from the microcontrollers must be
disregarded half a cycle later. When we reach bit stage 9, we start
sending the three status bits one cycle at a time. When we are about
to reach bit stage 12, we have sent all of data, and if there is no
new data from the microcontrollers (as indicated by di\_ready) we
return to the initial bit sending state. The error tags are
maintained, however, as these are separate memory elements stored in
the one bit voter.

An alternative might be to store the calculated data in a register, to
be sent later. This might yield more relaxed timing constraints, which
in turn should give a circuit able to operate at higher clock
frequencies. In turn, it is likely to be a bit bigger, as the register
write-enable logic has to be written in addition to the
output-selection logic.

\end{document}
